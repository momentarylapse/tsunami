use tsunami.*
use helper.draw.*
use synthesizer.Sample.*
use hui

let NSURFACES = 4
let NRIMS = 9


let SURFACE_PITCHES = [48, 50, 52, 53] # C3,D3,E3,F3
	# warning: Mandala calls these C2,D2,E2,F2
let RIM_PITCHES = [60, 62, 64, 65, 67, 69, 71, 72, 84] # C4,D4,...,C5, C6
	# warning: Mandala calls these C3,D3,...,C4, C5

func sample_name(sample: shared[SampleRef]) -> string
	for s in sample
		return s.origin.name
	return "---"

class Mandala extends TsunamiPlugin
	class Config extends Module.Config
		var device: Device*
		var number_of_zones: i32
		var surface_samples: shared[SampleRef][]
		var rim_samples: shared[SampleRef][]
		func override reset()
			device = nil
			number_of_zones = NSURFACES
			surface_samples.clear()
			surface_samples.resize(NSURFACES)
			rim_samples.clear()
			rim_samples.resize(NRIMS)
		
		func group_size() -> i32
			return NSURFACES / number_of_zones
		
	var config: Config
	
	var source: shared[MidiInput]
	var output: shared[AudioOutput]
	var synth: shared[SampleSynthesizer]
	var chain: shared[SignalChain]
	

	func override on_start()
		# create signal chain
		# [midi in] => [synth] => [audio out]
		chain = session.create_signal_chain("mandala")
		source = chain!.add[MidiInput]()
		source!.set_free_flow(true)
		output = chain!.add[AudioOutput]()
		synth = chain!.add[SampleSynthesizer]()
		chain!.connect(source, 0, synth, 0)
		chain!.connect(synth, 0, output, 0)
		chain!.start()

	func override on_stop()
		chain = nil
	
	func override on_config()
		for s in synth
			# configure synth with our samples
			s.config.samples.clear()
			s.config.samples.resize(128)
			let group_size = config.group_size()
			for i=>p in SURFACE_PITCHES
				let source = (i / group_size) * group_size # grouping? => round down
				if source < len(config.surface_samples)
					s.config.samples[p] = config.surface_samples[source]
			for i=>p in RIM_PITCHES
				if i < len(config.rim_samples)
					s.config.samples[p] = config.rim_samples[i]
			s.changed()
		for s in source
			s.set_device(config.device)
		
	
	func override create_panel() -> xfer[ConfigPanel]
		return new MandalaPanel(self)


class MandalaPanel extends ConfigPanel
	override c: Mandala&
	var config: Mandala.Config&
	var source_selector: owned![DeviceSelector]
	var width, height: i32
	
	struct Hover
		enum Type
			SURFACE
			RIM
		type: Type
		index: i32
	
	var hover: Hover?
	
	func override __init__(_s: Module)
		config := &c.config
		
		from_source("
Grid grid ''
	---|
	Grid ? ''
		Label ? 'Device'
		ComboBox source '' expandx
		---|
		Label ? 'Zones'
		ComboBox number-of-zones '1\\2\\4' expandx
	---|
	DrawingArea area '' expandx expandy")
	
		source_selector = new DeviceSelector(self, "source", c.session, Device.Type.MIDI_INPUT, on_source)
		
		event("number-of-zones", on_number_of_zones)
		event_x("area", "hui:draw", on_draw)
		event_x("area", "hui:mouse-move", on_mouse_move)
		event_x("area", "hui:left-button-down", on_left_button_down)
		event_x("area", "hui:mouse-leave", on_mouse_leave)
	
	func override update()
		set_int("number-of-zones", clamp(config.number_of_zones, 1, 3) - 1)
		redraw("area")
	
	func mut on_number_of_zones()
		let n = get_int("number-of-zones")
		config.number_of_zones = 2^n
		changed()
		redraw("area")
	
	func mut on_source()
		config.device = source_selector.get()
		
		changed()
	
	func draw_hollow_circle(p: hui.Painter, center: vec2, r0: f32, r1: f32)
		var v: vec2[]
		let N = 128
		for i in 0:N+1
			let phi = f32(i) / N * pi * 2
			v.add(center + vec2(cos(phi) * r0, sin(phi) * r0))
		for i in 0:N+1
			let phi = f32(N - i) / N * pi * 2
			v.add(center + vec2(cos(phi) * r1, sin(phi) * r1))
		p.draw_polygon(v)
	
	func mut on_draw(p: hui.Painter)
		width = p.width
		height = p.height
		
		p.set_color(theme.background)
		p.draw_rect([0,width, 0,height])
		
		
		# left: surfaces
		let c1 = vec2(width / 4, height / 2)
		let r = min(c1.x, c1.y) * 0.9
		
		let group_size = config.group_size()
		
		for i in 0:NSURFACES
			if (i % group_size) == 0
				var hovering = false
				for h in hover
					if h.type == Hover.Type.SURFACE and h.index >= i and h.index < i + group_size
						hovering = true
				let alpha = if hovering
					0.6
				else
					0.3
				p.set_color(theme.neon(4 - i).with_alpha(alpha))
				let r0 = r/NSURFACES*i
				let r1 = r/NSURFACES*(i+group_size)
				draw_hollow_circle(p, c1, r0, r1)
				var fs = 8.0
				p.set_color(theme.text_soft2)
				if hovering
					p.set_color(theme.text)
					fs = 10.0
				p.set_font_size(fs)
				p.draw_str(c1 + vec2(-2, -r0 - fs*1.7), str(i+1))
		p.set_fill(false)
		p.set_color(theme.text)
		p.draw_circle(c1, r)
		if config.number_of_zones == 4
			p.draw_circle(c1, r*0.75)
		if config.number_of_zones != 1
			p.draw_circle(c1, r*0.5)
		if config.number_of_zones == 4
			p.draw_circle(c1, r*0.25)
		
		
		# right: rims
		let c2 = vec2(width * 3 / 4, height / 2)
		p.set_color(theme.neon(4).with_alpha(0.3))
		p.set_fill(true)
		p.draw_circle(c2, r)
		p.set_fill(false)
		p.set_color(theme.text)
		p.draw_circle(c2, r)
		p.set_fill(true)
		p.set_font_size(8)
		for i in 0:NRIMS
			var hovering = false
			for h in hover
				if h.type == Hover.Type.RIM and h.index == i
					hovering = true
			let phi = f32(i) / NRIMS * 2 * pi
			p.set_color(theme.text)
			p.draw_circle(c2 + r * vec2(sin(phi), -cos(phi)), 5)
			let phi2 = phi + pi / NRIMS
			var fs = 8.0
			p.set_color(theme.text_soft2)
			if hovering
				p.set_color(theme.text)
				fs = 10.0
			p.set_font_size(fs)
			p.draw_str(c2 + (r - 13) * vec2(sin(phi2), -cos(phi2)) + vec2(-fs/2,-fs/2), str(i+1))
		
		
		# tooltip
		for h in hover
			if h.type == Hover.Type.SURFACE
				draw_cursor_hover(p, "Surface #{{h.index+1}} - sample: {{sample_name(config.surface_samples[h.index])}}", hui.get_event().mouse, [0,width, 0,height])
			if h.type == Hover.Type.RIM
				draw_cursor_hover(p, "Rim #{{h.index+1}} - sample: {{sample_name(config.rim_samples[h.index])}}", hui.get_event().mouse, [0,width, 0,height])
	
	func get_hover(m: vec2) -> Hover?
		# left: surfaces
		let c1 = vec2(width / 4, height / 2)
		let r = min(c1.x, c1.y) * 0.9
		
		for i in 0:NSURFACES
			if len(m - c1) < r * f32(i + 1) / f32(NSURFACES)
				return [Hover.Type.SURFACE, i]
		
		
		# right: rims
		let c2 = vec2(width * 3 / 4, height / 2)
		for i in 0:NRIMS
			let phi = (f32(i) + 0.5) / NRIMS * 2 * pi
			let c = c2 + (r - 13) * vec2(sin(phi), -cos(phi))
			if len(m - c) < r * 0.3
				return [Hover.Type.RIM, i]
		
		return nil
	
	func mut on_mouse_move()
		hover = get_hover(hui.get_event().mouse)
		redraw("area")
	
	func mut on_mouse_leave()
		hover = nil
		redraw("area")

	func mut on_left_button_down()
		for h in hover
			if h.type == Hover.Type.SURFACE
				let i = h.index
				var old: Sample* = nil
				for s in config.surface_samples[i]
					old = &s.origin
				let f = func(ss: Sample*)
					for _s in ss
						config.surface_samples[i] = _s.create_ref()
					else
						config.surface_samples[i] = nil
					changed()
					update()
				SelectSample(c.session, self, old).then(f)
			if h.type == Hover.Type.RIM
				let i = h.index
				var old: Sample* = nil
				for s in config.rim_samples[i]
					old = &s.origin
				let f = func(ss: Sample*)
					for _s in ss
						config.rim_samples[i] = _s.create_ref()
					else
						config.rim_samples[i] = nil
					changed()
					update()
				SelectSample(c.session, self, old).then(f)
		
